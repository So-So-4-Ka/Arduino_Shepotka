#define LED1 PB5

ISR(TIMER2_COMPA_vect) //прерывание по COMPA
{
  PORTB &= ~(1 << LED1);//гасим светодиод
} 

ISR(TIMER2_COMPB_vect)// прерывание по COMPB
{//если разрешали прерывание, его обязательно надо прописать в коде 

} 

ISR(TIMER2_OVF_vect) //прерывание по переполнению
{
  PORTB |= (1 << LED1); //включаем светодиод
}
ISR (ADC_vect)//прерывание преобразования АЦП
{
  ADCSRA |= (1<<ADSC);//начинаем преобразование
  OCR2A=(0.25)*ADC+1;//нехитрый расчет по формуле выше
} 

int main (void)
{
  Serial.begin(115200);
  DDRB |= (1 << LED1); // Set LED pins as outputs 

  //блок иницализации таймера
  TCCR2A = (1<<WGM21)|(1<<WGM20);//fast WPM MODE
  TCCR2B = (1 << CS02) |(1 << CS01) | (1 << CS00); // Делитель на 1024
  OCR2A = 100; // Для периода 500 мс при частоте 16 МГц и делителена 1024
  OCR2B = 100;
  TIMSK2 = (1 << OCIE2B)| (1<<TOIE2)|(1 <<OCIE2A);// Разрешить прерывание по сравнению с OCR2A и OCR2B 

  sei(); // Enable global interrupts


  //блок иницализации АЦП
  ADMUX = (1<<REFS0)| //опорное напряжение = VCC(5В)
  (1<<MUX0); //Входное напряжение к AD1
  ADCSRA = (1<<ADEN)|(1<<ADSC)// //разрешаем работу АЦП и инициируем первое преобразование
  |(1 << ADPS2) |(1 << ADPS1)| (1 <<ADPS0) //предделитель на 128
  |(1 << ACIE);//разрешаем прерывания


  while(1)
  {//PORTB |= (1 << LED1);
    //ничего не делаем, МК сам всё сделает
    Serial.println(OCR2A);
  }
} 